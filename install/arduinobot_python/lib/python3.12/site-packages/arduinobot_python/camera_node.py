import rclpy
from rclpy.node import Node
from sensor_msgs.msg import Image, CameraInfo
from cv_bridge import CvBridge
from tf2_ros import TransformListener, Buffer
from std_msgs.msg import Float64MultiArray, Int64MultiArray
import math
from ultralytics import YOLO
import numpy as np
import threading



class ImageSubscriber(Node):
    def __init__(self):
        super().__init__('compute_node')

        # Variable to store the latest frame
        self.latest_rgb_frame = None
        self.latest_depth_frame = None
        
        self.fx = self.fy = self.cx = self.cy = None
        self.target_point = np.zeros(3, dtype=float)
        self.frame_lock = threading.Lock()  # Lock to ensure thread safety
        self.tf_buffer = Buffer()
        self.tf_listener = TransformListener(self.tf_buffer, self)
        # Initialize CvBridge
        self.bridge = CvBridge()
        # self.model = YOLO("yolov8n.pt")
        
        # Flag to control the display loop
        self.running = True
        self.declare_parameter("claw_sp_length", 0.59) 
        self.claw_sp_length = self.get_parameter("claw_sp_length").get_parameter_value().double_value
        self.claw_sp_width = 0.0
         
        # self.camera_x, self.camera_y  = self.get_camera_pose()
        self.camera_x = 0.0
        self.camera_y = 0.0
        self.camera_z = 0.0
    
        # Subcription info
        self.create_subscription(CameraInfo, '/camera/image/camera_info', self.info_callback, 10)
        self.create_subscription(Int64MultiArray, '/pick_object_point', self.pick_object_callback, 10)

        # Create a subscriber with a queue size of 1 to only keep the last frame
        self.sub_rgb = self.create_subscription(
            Image,
            'camera/image',
            self.image_callback,
            1  # Queue size of 1
        )
        
        self.sub_depth = self.create_subscription(
            Image,
            'camera/depth_image',
            self.depth_image_callback,
            1  # Queue size of 1
        )

        self.coord_pub = self.create_publisher(Float64MultiArray, "/target_point", 10)


    def get_camera_pose(self):
        #Camera 
        while self.tf_buffer.can_transform("base_link", "rgb_camera", rclpy.time.Time(), timeout=rclpy.duration.Duration(seconds=1.0)):
            try:
                trans = self.tf_buffer.lookup_transform(
                    'forward_drive_arm',  
                    'rgb_camera',
                    rclpy.time.Time())
                self.camera_x = trans.transform.translation.x
                self.camera_y = trans.transform.translation.y
                self.camera_z = trans.transform.translation.z
            
                self.get_logger().info('Camera position: x=' + str(self.camera_x) + ', y=' + str(self.camera_y)+ ', z=' + str(self.camera_z))
                break
                
            except Exception as e:
                self.get_logger().warn(f'Cannot get transform: {e}')
                break
            
            
    def info_callback(self, msg):
        self.fx = msg.k[0]
        self.fy = msg.k[4]
        self.cx = msg.k[2]
        self.cy = msg.k[5]

    def image_callback(self, msg):
        with self.frame_lock:
            self.latest_rgb_frame = self.bridge.imgmsg_to_cv2(msg, "bgr8")

    def depth_image_callback(self, msg):
        with self.frame_lock:
            self.latest_depth_frame = self.bridge.imgmsg_to_cv2(msg, "passthrough")
            # self.get_logger().info(msg.encoding)
    

    def pick_object_callback(self, msg):
        self.get_logger().info("pick_object_callback " )
        arr = np.array(msg.data, dtype=np.int64)
        self.get_logger().info(f"{arr}")
        self.calculate_point(arr[0], arr[1])
        
    def calculate_point(self, cx, cy):     
        try:   
            if self.latest_depth_frame is not None and self.latest_rgb_frame is not None:            
                # Đọc depth tại điểm giữa
                depth = self.latest_depth_frame[cy, cx]
                self.get_logger().info("depth = " + str(depth))
                self.get_logger().info("depth = " + str(depth))
                self.get_logger().info("depth = " + str(depth))
                if np.isnan(depth) or depth == 0.0:
                    self.get_logger().warn("Invalid depth value.")
                    return
                
                self.get_camera_pose()
                # self.get_logger().info(f'cx={cx}, cy={cy}, self.cx={self.cx},self.cy={self.cy}')
                self.get_logger().info(f'depth={depth}')
                # self.get_logger().info(f'self.fx={self.fx},self.fy={self.fy}')
                # self.get_logger().info(f'depth*(cy - self.cy)/self.fy={depth*(cy - self.cy)/self.fy}')
                # self.get_logger().info(f'depth*(cx - self.cx)/self.fx={depth*(cx - self.cx)/self.fx}')
                # self.get_logger().info('Camera position: x=' + str(self.camera_x) + ', y=' + str(self.camera_y)+ ', z=' + str(self.camera_z))

                Az = depth*(cy - self.cy)/float(self.fy) + self.camera_z  
                Ax = depth*(cx - self.cx)/float(self.fx)  + self.camera_x
                Ay = depth + self.camera_y
                self.get_logger().info(f'Ax Ay Az = {Ax}, {Ay}, {Ax}')

                length_point_2_camera = math.sqrt(Ax**2 + Ay**2)

                self.get_logger().info(f'length_point_2_camera = {length_point_2_camera}')
                self.get_logger().info(f'claw_sp_length = {self.claw_sp_length}')
                Ax = Ax* (1-self.claw_sp_length/length_point_2_camera)
                Ay = Ay* (1-self.claw_sp_length/length_point_2_camera)
                
                # Dich 1 doan bang chieu ngang cua claw sp
                length_OAxy = math.sqrt(Ax**2 + Ay**2)
                vx = Ay * self.claw_sp_width/ length_OAxy
                vy = -Ax * self.claw_sp_width/ length_OAxy

                # self.target_point= [0.0,0.0,0.0]
                self.target_point[0] = Ax + vx
                self.target_point[1] = Ay + vy
                self.target_point[2] = Az

                self.get_logger().info("target point = " + str(self.target_point))
                angles = self.compute_ik()
                self.get_logger().info("Joint angles (radians):" + str(angles))
                msg = Float64MultiArray()
                msg.data = angles
                self.coord_pub.publish(msg)
        except Exception as e:
            self.get_logger().warn(f'Cannot get calculate_point: {e}')
            return

    def stop(self):
            """Stop the node and the spin thread."""
            self.running = False
            self.spin_thread.join()

    def rad_to_deg(self, rad):
        return rad * 180.0 / np.pi

    def compute_ik(self):
        if self.target_point.shape != (3,):
            raise ValueError("target_point must be a 3-element vector")
        # 0.5757      1.4587    -0.25692  
        x, y, z = self.target_point
        L1 = 0.8
        L2 = 0.82
        base_z = 0.3

        theta1 = np.arctan2(y, x) - np.pi / 2
        self.get_logger().info(f"x: {x:.3f}")
        self.get_logger().info(f"y: {y:.3f}")
        self.get_logger().info(f"z: {z:.3f}")
        self.get_logger().info(f"theta1: {self.rad_to_deg(theta1):.3f} deg")

        r = np.sqrt(x**2 + y**2)
        z_rel = z - base_z
        self.get_logger().info(f"z_rel: {z_rel:.3f}")

        D = np.sqrt(r**2 + z_rel**2)
        self.get_logger().info(f"D: {D:.3f}")

        if D > (L1 + L2):
            self.get_logger().info("Target is out of reach, D = " + str(D))
            return

        angle_a = np.arccos((L1**2 + D**2 - L2**2) / (2 * L1 * D))
        self.get_logger().info(f"angle_a: {self.rad_to_deg(angle_a):.3f} deg")

        angle_b = np.arctan2(z_rel, r)
        self.get_logger().info(f"angle_b: {self.rad_to_deg(angle_b):.3f} deg")

        theta2 = angle_b + angle_a
        theta2 = -np.pi/2 + theta2
        self.get_logger().info(f"theta2: {self.rad_to_deg(theta2):.3f} deg")

        angle_c = np.arccos((L1**2 + L2**2 - D**2) / (2 * L1 * L2))
        self.get_logger().info(f"angle_c: {self.rad_to_deg(angle_c):.3f} deg")

        theta3 = angle_c
        self.get_logger().info(f"theta3 before adjust: {self.rad_to_deg(theta3):.3f} deg")

        theta4 = np.pi/2 - (theta2 + theta3)
        self.get_logger().info(f"theta4: {self.rad_to_deg(theta4):.3f} deg")

        theta3 = -np.pi/2 + theta3
        self.get_logger().info(f"theta3: {self.rad_to_deg(theta3):.3f} deg")

        return [theta1, theta2, theta3, theta4]


def main(args=None):
    rclpy.init(args=args)
    node = ImageSubscriber()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()